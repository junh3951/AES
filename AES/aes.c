#include <stdint.h>
#include <string.h>
#include "aes.h"

char SUBMISSION_INFO[256] = "2019170371_LeeJunhyoung";


//128-bit block
//typedef uint8_t AES_STATE_t[16];
//128-bit masterkey
//typedef uint8_t AES128_KEY_t[16];

uint8_t GFMulti(uint8_t x, uint8_t mul) {
    uint8_t result = 0;

    for (int i = 0; i < 8; i++) {
        if ((mul & 1) != 0)
            result ^= x;

        uint8_t carry = x & 0x80;

        x <<= 1;

        if (carry != 0)
            x ^= 0x1b;

        mul >>= 1;
    }

    return result;
}


uint8_t Rcon(uint8_t i) {
    uint8_t rcon = 0x01;
    if (i == 0) return 0;

    while (i != 1) {
        rcon = GFMulti(rcon, 2);
        i--;
    }

    return rcon;
}



void AES128_enc(AES_STATE_t C, AES_STATE_t P, AES128_KEY_t K128)
{
	
	
	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = SubBytes[i];
		T0[i] = (1<<24)*GFMulti(c,2) + (1<<16)*c + (1<<8)*c + (1<<0)*GFMulti(c,3);
		T1[i] = (1<<24)*GFMulti(c,3) + (1<<16)*GFMulti(c,2) + (1<<8)*c + (1<<0)*c;
		T2[i] = (1<<24)*c + (1<<16)*GFMulti(c,3) + (1<<8)*GFMulti(c,2) + (1<<0)*c;
		T3[i] = (1<<24)*c + (1<<16)*c + (1<<8)*GFMulti(c,3) + (1<<0)*GFMulti(c,2);
	}

	
	// Round Key(11)
	uint32_t W[44];
	for (int i = 0; i < 4; i++)
	{
		W[i] = (1<<24)*K128[0+4*i] + (1<<16)*K128[1+4*i] + (1<<8)*K128[2+4*i] + (1<<0)*K128[3+4*i];
	}
	for (int i = 0; i < 10; i++)
	{
		uint8_t k[4];
		k[0] = SubBytes[(W[4*i+3]/(256*256))%(256)];
		k[1] = SubBytes[(W[4*i+3]/256)%(256)];
		k[2] = SubBytes[W[4*i+3]%(256)];
		k[3] = SubBytes[(W[4*i+3]/(256*256*256))%(256)];

		
		W[4*i+4] = W[4*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
		W[4*i+5] = W[4*i+1] ^ W[4*i+4];
		W[4*i+6] = W[4*i+2] ^ W[4*i+5];
		W[4*i+7] = W[4*i+3] ^ W[4*i+6];
	}
	

	// Round Iteration(10)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, P, sizeof(AES_STATE_t));

	// Round 0
	for (int i = 0; i < 16; i++)
		C[i] = P_tmp[i] ^ ((W[i/4] >> (24-8*(i%4))) & 0xFF);
	memcpy(P_tmp, C, sizeof(AES_STATE_t));
	
	// Iteration
	for (int i = 0; i < 9; i++)
	{
		C[0] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 24) & 0xFF;
		C[1] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 16) & 0xFF;
		C[2] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 8) & 0xFF;
		C[3] = (T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) & 0xFF;

		C[4] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 24) & 0xFF;
		C[5] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 16) & 0xFF;
		C[6] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 8) & 0xFF;
		C[7] = (T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) & 0xFF;

		C[8] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 24) & 0xFF;
		C[9] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 16) & 0xFF;
		C[10] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 8) & 0xFF;
		C[11] = (T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) & 0xFF;

		C[12] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 24) & 0xFF;
		C[13] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 16) & 0xFF;
		C[14] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 8) & 0xFF;
		C[15] = (T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) & 0xFF;

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+4*(i+1)] >> (24-8*(k%4))) & 0xFF);
		memcpy(P_tmp, C, sizeof(AES_STATE_t));
	}

	// Final Round
		C[0] = SubBytes[P_tmp[0]];
		C[1] = SubBytes[P_tmp[5]];
		C[2] = SubBytes[P_tmp[10]];
		C[3] = SubBytes[P_tmp[15]];
		C[4] = SubBytes[P_tmp[4]];
		C[5] = SubBytes[P_tmp[9]];
		C[6] = SubBytes[P_tmp[14]];
		C[7] = SubBytes[P_tmp[3]];
		C[8] = SubBytes[P_tmp[8]];
		C[9] = SubBytes[P_tmp[13]];
		C[10] = SubBytes[P_tmp[2]];
		C[11] = SubBytes[P_tmp[7]];
		C[12] = SubBytes[P_tmp[12]];
		C[13] = SubBytes[P_tmp[1]];
		C[14] = SubBytes[P_tmp[6]];
		C[15] = SubBytes[P_tmp[11]];
		

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+40] >> (24-8*(k%4))) & 0xFF);
	
	
}


void AES128_dec(AES_STATE_t P, AES_STATE_t C, AES128_KEY_t K128)
{
	// Round Key(11)
	
	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};

	
	uint32_t W[44];
	for (int i = 0; i < 4; i++)
	{
		W[i] = (1<<24)*K128[0+4*i] + (1<<16)*K128[1+4*i] + (1<<8)*K128[2+4*i] + (1<<0)*K128[3+4*i];
	}
	for (int i = 0; i < 10; i++)
	{
		uint8_t k[4];
		k[0] = SubBytes[(W[4*i+3]/(256*256))%(256)];
		k[1] = SubBytes[(W[4*i+3]/256)%(256)];
		k[2] = SubBytes[W[4*i+3]%(256)];
		k[3] = SubBytes[(W[4*i+3]/(256*256*256))%(256)];

		
		W[4*i+4] = W[4*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
		W[4*i+5] = W[4*i+1] ^ W[4*i+4];
		W[4*i+6] = W[4*i+2] ^ W[4*i+5];
		W[4*i+7] = W[4*i+3] ^ W[4*i+6];
	}

	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t Inv_SubBytes[256] = 
		{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = i;
		T0[i] = (1<<24)*GFMulti(c,0x0E) + (1<<16)*GFMulti(c,0x09) + (1<<8)*GFMulti(c,0x0D) + (1<<0)*GFMulti(c,0x0B);
		T1[i] = (1<<24)*GFMulti(c,0x0B) + (1<<16)*GFMulti(c,0x0E) + (1<<8)*GFMulti(c,0x09) + (1<<0)*GFMulti(c,0x0D);
		T2[i] = (1<<24)*GFMulti(c,0x0D) + (1<<16)*GFMulti(c,0x0B) + (1<<8)*GFMulti(c,0x0E) + (1<<0)*GFMulti(c,0x09);
		T3[i] = (1<<24)*GFMulti(c,0x09) + (1<<16)*GFMulti(c,0x0D) + (1<<8)*GFMulti(c,0x0B) + (1<<0)*GFMulti(c,0x0E);
	}

	// Round Iteration(10)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, C, sizeof(AES_STATE_t));

	// Inv Final Round 
	for (int k = 0; k < 16; k++)
		P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+40] >> (24-8*(k%4))) & 0xFF);

	P[0] = Inv_SubBytes[P_tmp[0]];
	P[1] = Inv_SubBytes[P_tmp[13]];
	P[2] = Inv_SubBytes[P_tmp[10]];
	P[3] = Inv_SubBytes[P_tmp[7]];

	P[4] = Inv_SubBytes[P_tmp[4]];
	P[5] = Inv_SubBytes[P_tmp[1]];
	P[6] = Inv_SubBytes[P_tmp[14]];
	P[7] = Inv_SubBytes[P_tmp[11]];
	
	P[8] = Inv_SubBytes[P_tmp[8]];
	P[9] = Inv_SubBytes[P_tmp[5]];
	P[10] = Inv_SubBytes[P_tmp[2]];
	P[11] = Inv_SubBytes[P_tmp[15]];
	
	P[12] = Inv_SubBytes[P_tmp[12]];
	P[13] = Inv_SubBytes[P_tmp[9]];
	P[14] = Inv_SubBytes[P_tmp[6]];
	P[15] = Inv_SubBytes[P_tmp[3]];


	// Iteration
	for (int i = 0; i < 9; i++)
	{
		memcpy(P_tmp, P, sizeof(AES_STATE_t));
		
		for (int k = 0; k < 16; k++)
			P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+4*(9-i)] >> (24-8*(k%4))) & 0xFF);
		
		P[0] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 24) & 0xFF];
		P[1] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 16) & 0xFF];
		P[2] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 8) & 0xFF];
		P[3] = Inv_SubBytes[(T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) & 0xFF];

		P[4] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 24) & 0xFF];
		P[5] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 16) & 0xFF];
		P[6] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 8) & 0xFF];
		P[7] = Inv_SubBytes[(T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) & 0xFF];

		P[8] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 24) & 0xFF];
		P[9] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 16) & 0xFF];
		P[10] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 8) & 0xFF];
		P[11] = Inv_SubBytes[(T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) & 0xFF];

		P[12] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 24) & 0xFF];
		P[13] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 16) & 0xFF];
		P[14] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 8) & 0xFF];
		P[15] = Inv_SubBytes[(T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) & 0xFF];
	}

	// Inv Round 0
	for (int k = 0; k < 16; k++)
		P[k] = P[k] ^ ((W[k/4] >> (24-8*(k%4))) & 0xFF);

}

//128-bit block
//typedef uint8_t AES_STATE_t[16];
//192-bit masterkey
//typedef uint8_t AES192_KEY_t[24];

void AES192_enc(AES_STATE_t C, AES_STATE_t P, AES192_KEY_t K192)
{
	
	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = SubBytes[i];
		T0[i] = (1<<24)*GFMulti(c,2) + (1<<16)*c + (1<<8)*c + (1<<0)*GFMulti(c,3);
		T1[i] = (1<<24)*GFMulti(c,3) + (1<<16)*GFMulti(c,2) + (1<<8)*c + (1<<0)*c;
		T2[i] = (1<<24)*c + (1<<16)*GFMulti(c,3) + (1<<8)*GFMulti(c,2) + (1<<0)*c;
		T3[i] = (1<<24)*c + (1<<16)*c + (1<<8)*GFMulti(c,3) + (1<<0)*GFMulti(c,2);
	}

	
	// Round Key(13)
	uint32_t W[52];
	for (int i = 0; i < 6; i++) {
    	W[i] = (1<<24)*K192[0+4*i] + (1<<16)*K192[1+4*i] + (1<<8)*K192[2+4*i] + (1<<0)*K192[3+4*i];
	}

	for (int i = 0; i < 8; i++) {
    	uint8_t k[4];
    	k[0] = SubBytes[(W[6*i+5]/(256*256))%(256)];
    	k[1] = SubBytes[(W[6*i+5]/256)%(256)];
    	k[2] = SubBytes[W[6*i+5]%(256)];
    	k[3] = SubBytes[(W[6*i+5]/(256*256*256))%(256)];

	    W[6*i+6] = W[6*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
	    W[6*i+7] = W[6*i+1] ^ W[6*i+6];
    	W[6*i+8] = W[6*i+2] ^ W[6*i+7];
    	W[6*i+9] = W[6*i+3] ^ W[6*i+8];

    
    	if (i < 7) {
        	W[6*i+10] = W[6*i+4] ^ W[6*i+9];
        	W[6*i+11] = W[6*i+5] ^ W[6*i+10];
    	}
	}

	

	// Round Iteration(12)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, P, sizeof(AES_STATE_t));

	// Round 0
	for (int i = 0; i < 16; i++)
		C[i] = P_tmp[i] ^ ((W[i/4] >> (24-8*(i%4))) & 0xFF);
	memcpy(P_tmp, C, sizeof(AES_STATE_t));
	
	// Iteration
	for (int i = 0; i < 11; i++)
	{
		C[0] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 24) & 0xFF;
		C[1] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 16) & 0xFF;
		C[2] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 8) & 0xFF;
		C[3] = (T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) & 0xFF;

		C[4] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 24) & 0xFF;
		C[5] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 16) & 0xFF;
		C[6] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 8) & 0xFF;
		C[7] = (T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) & 0xFF;

		C[8] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 24) & 0xFF;
		C[9] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 16) & 0xFF;
		C[10] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 8) & 0xFF;
		C[11] = (T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) & 0xFF;

		C[12] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 24) & 0xFF;
		C[13] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 16) & 0xFF;
		C[14] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 8) & 0xFF;
		C[15] = (T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) & 0xFF;

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+4*(i+1)] >> (24-8*(k%4))) & 0xFF);
		memcpy(P_tmp, C, sizeof(AES_STATE_t));
	}

	// Final Round
		C[0] = SubBytes[P_tmp[0]];
		C[1] = SubBytes[P_tmp[5]];
		C[2] = SubBytes[P_tmp[10]];
		C[3] = SubBytes[P_tmp[15]];
		C[4] = SubBytes[P_tmp[4]];
		C[5] = SubBytes[P_tmp[9]];
		C[6] = SubBytes[P_tmp[14]];
		C[7] = SubBytes[P_tmp[3]];
		C[8] = SubBytes[P_tmp[8]];
		C[9] = SubBytes[P_tmp[13]];
		C[10] = SubBytes[P_tmp[2]];
		C[11] = SubBytes[P_tmp[7]];
		C[12] = SubBytes[P_tmp[12]];
		C[13] = SubBytes[P_tmp[1]];
		C[14] = SubBytes[P_tmp[6]];
		C[15] = SubBytes[P_tmp[11]];
		

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+48] >> (24-8*(k%4))) & 0xFF);
	
	
}


void AES192_dec(AES_STATE_t P, AES_STATE_t C, AES192_KEY_t K192)
{
	// Round Key(13)
	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};

	uint32_t W[52];
	for (int i = 0; i < 6; i++) {
    	W[i] = (1<<24)*K192[0+4*i] + (1<<16)*K192[1+4*i] + (1<<8)*K192[2+4*i] + (1<<0)*K192[3+4*i];
	}

	for (int i = 0; i < 8; i++) {
    	uint8_t k[4];
    	k[0] = SubBytes[(W[6*i+5]/(256*256))%(256)];
    	k[1] = SubBytes[(W[6*i+5]/256)%(256)];
    	k[2] = SubBytes[W[6*i+5]%(256)];
    	k[3] = SubBytes[(W[6*i+5]/(256*256*256))%(256)];

	    W[6*i+6] = W[6*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
	    W[6*i+7] = W[6*i+1] ^ W[6*i+6];
    	W[6*i+8] = W[6*i+2] ^ W[6*i+7];
    	W[6*i+9] = W[6*i+3] ^ W[6*i+8];

    
    	if (i < 7) {
        	W[6*i+10] = W[6*i+4] ^ W[6*i+9];
        	W[6*i+11] = W[6*i+5] ^ W[6*i+10];
    	}
	}


	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t Inv_SubBytes[256] = 
		{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = i;
		T0[i] = (1<<24)*GFMulti(c,0x0E) + (1<<16)*GFMulti(c,0x09) + (1<<8)*GFMulti(c,0x0D) + (1<<0)*GFMulti(c,0x0B);
		T1[i] = (1<<24)*GFMulti(c,0x0B) + (1<<16)*GFMulti(c,0x0E) + (1<<8)*GFMulti(c,0x09) + (1<<0)*GFMulti(c,0x0D);
		T2[i] = (1<<24)*GFMulti(c,0x0D) + (1<<16)*GFMulti(c,0x0B) + (1<<8)*GFMulti(c,0x0E) + (1<<0)*GFMulti(c,0x09);
		T3[i] = (1<<24)*GFMulti(c,0x09) + (1<<16)*GFMulti(c,0x0D) + (1<<8)*GFMulti(c,0x0B) + (1<<0)*GFMulti(c,0x0E);
	}

	// Round Iteration(12)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, C, sizeof(AES_STATE_t));

	// Inv Final Round 
	for (int k = 0; k < 16; k++)
		P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+48] >> (24-8*(k%4))) & 0xFF);

	P[0] = Inv_SubBytes[P_tmp[0]];
	P[1] = Inv_SubBytes[P_tmp[13]];
	P[2] = Inv_SubBytes[P_tmp[10]];
	P[3] = Inv_SubBytes[P_tmp[7]];

	P[4] = Inv_SubBytes[P_tmp[4]];
	P[5] = Inv_SubBytes[P_tmp[1]];
	P[6] = Inv_SubBytes[P_tmp[14]];
	P[7] = Inv_SubBytes[P_tmp[11]];
	
	P[8] = Inv_SubBytes[P_tmp[8]];
	P[9] = Inv_SubBytes[P_tmp[5]];
	P[10] = Inv_SubBytes[P_tmp[2]];
	P[11] = Inv_SubBytes[P_tmp[15]];
	
	P[12] = Inv_SubBytes[P_tmp[12]];
	P[13] = Inv_SubBytes[P_tmp[9]];
	P[14] = Inv_SubBytes[P_tmp[6]];
	P[15] = Inv_SubBytes[P_tmp[3]];


	// Iteration
	for (int i = 0; i < 11; i++)
	{
		memcpy(P_tmp, P, sizeof(AES_STATE_t));
		
		for (int k = 0; k < 16; k++)
			P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+4*(11-i)] >> (24-8*(k%4))) & 0xFF);
		
		P[0] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 24) & 0xFF];
		P[1] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 16) & 0xFF];
		P[2] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 8) & 0xFF];
		P[3] = Inv_SubBytes[(T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) & 0xFF];

		P[4] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 24) & 0xFF];
		P[5] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 16) & 0xFF];
		P[6] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 8) & 0xFF];
		P[7] = Inv_SubBytes[(T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) & 0xFF];

		P[8] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 24) & 0xFF];
		P[9] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 16) & 0xFF];
		P[10] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 8) & 0xFF];
		P[11] = Inv_SubBytes[(T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) & 0xFF];

		P[12] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 24) & 0xFF];
		P[13] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 16) & 0xFF];
		P[14] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 8) & 0xFF];
		P[15] = Inv_SubBytes[(T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) & 0xFF];
	}

	// Inv Round 0
	for (int k = 0; k < 16; k++)
		P[k] = P[k] ^ ((W[k/4] >> (24-8*(k%4))) & 0xFF);

}


//128-bit block
//typedef uint8_t AES_STATE_t[16];
//256-bit masterkey
//typedef uint8_t AES256_KEY_t[32];

void AES256_enc(AES_STATE_t C, AES_STATE_t P, AES256_KEY_t K256)
{
	
	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = SubBytes[i];
		T0[i] = (1<<24)*GFMulti(c,2) + (1<<16)*c + (1<<8)*c + (1<<0)*GFMulti(c,3);
		T1[i] = (1<<24)*GFMulti(c,3) + (1<<16)*GFMulti(c,2) + (1<<8)*c + (1<<0)*c;
		T2[i] = (1<<24)*c + (1<<16)*GFMulti(c,3) + (1<<8)*GFMulti(c,2) + (1<<0)*c;
		T3[i] = (1<<24)*c + (1<<16)*c + (1<<8)*GFMulti(c,3) + (1<<0)*GFMulti(c,2);
	}

	
	// Round Key(15)
	uint32_t W[60];
	for (int i = 0; i < 8; i++) {
		W[i] = (1<<24)*K256[0+4*i] + (1<<16)*K256[1+4*i] + (1<<8)*K256[2+4*i] + (1<<0)*K256[3+4*i];
	}

	for (int i = 0; i < 7; i++) {
		uint8_t k[4];
		k[0] = SubBytes[(W[8*i+7]/(256*256))%(256)];
		k[1] = SubBytes[(W[8*i+7]/256)%(256)];
		k[2] = SubBytes[W[8*i+7]%(256)];
		k[3] = SubBytes[(W[8*i+7]/(256*256*256))%(256)];

		W[8*i+8] = W[8*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
		W[8*i+9] = W[8*i+1] ^ W[8*i+8];
		W[8*i+10] = W[8*i+2] ^ W[8*i+9];
		W[8*i+11] = W[8*i+3] ^ W[8*i+10];

		if (i < 6) {
			k[0] = SubBytes[W[8*i+11]%(256)];
			k[1] = SubBytes[(W[8*i+11]/256)%(256)];
			k[2] = SubBytes[(W[8*i+11]/(256*256))%(256)];
			k[3] = SubBytes[(W[8*i+11]/(256*256*256))%(256)];

			W[8*i+12] = W[8*i+4] ^ k[0] + (k[1]<<8) + (k[2]<<16) + (k[3]<<24);
			W[8*i+13] = W[8*i+5] ^ W[8*i+12];
			W[8*i+14] = W[8*i+6] ^ W[8*i+13];
			W[8*i+15] = W[8*i+7] ^ W[8*i+14];
		}
	}


	

	// Round Iteration(14)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, P, sizeof(AES_STATE_t));

	// Round 0
	for (int i = 0; i < 16; i++)
		C[i] = P_tmp[i] ^ ((W[i/4] >> (24-8*(i%4))) & 0xFF);
	memcpy(P_tmp, C, sizeof(AES_STATE_t));
	
	// Iteration
	for (int i = 0; i < 13; i++)
	{
		C[0] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 24) & 0xFF;
		C[1] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 16) & 0xFF;
		C[2] = ((T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) >> 8) & 0xFF;
		C[3] = (T0[P_tmp[0]]^T1[P_tmp[5]]^T2[P_tmp[10]]^T3[P_tmp[15]]) & 0xFF;

		C[4] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 24) & 0xFF;
		C[5] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 16) & 0xFF;
		C[6] = ((T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) >> 8) & 0xFF;
		C[7] = (T0[P_tmp[4]]^T1[P_tmp[9]]^T2[P_tmp[14]]^T3[P_tmp[3]]) & 0xFF;

		C[8] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 24) & 0xFF;
		C[9] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 16) & 0xFF;
		C[10] = ((T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) >> 8) & 0xFF;
		C[11] = (T0[P_tmp[8]]^T1[P_tmp[13]]^T2[P_tmp[2]]^T3[P_tmp[7]]) & 0xFF;

		C[12] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 24) & 0xFF;
		C[13] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 16) & 0xFF;
		C[14] = ((T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) >> 8) & 0xFF;
		C[15] = (T0[P_tmp[12]]^T1[P_tmp[1]]^T2[P_tmp[6]]^T3[P_tmp[11]]) & 0xFF;

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+4*(i+1)] >> (24-8*(k%4))) & 0xFF);
		memcpy(P_tmp, C, sizeof(AES_STATE_t));
	}

	// Final Round
		C[0] = SubBytes[P_tmp[0]];
		C[1] = SubBytes[P_tmp[5]];
		C[2] = SubBytes[P_tmp[10]];
		C[3] = SubBytes[P_tmp[15]];
		C[4] = SubBytes[P_tmp[4]];
		C[5] = SubBytes[P_tmp[9]];
		C[6] = SubBytes[P_tmp[14]];
		C[7] = SubBytes[P_tmp[3]];
		C[8] = SubBytes[P_tmp[8]];
		C[9] = SubBytes[P_tmp[13]];
		C[10] = SubBytes[P_tmp[2]];
		C[11] = SubBytes[P_tmp[7]];
		C[12] = SubBytes[P_tmp[12]];
		C[13] = SubBytes[P_tmp[1]];
		C[14] = SubBytes[P_tmp[6]];
		C[15] = SubBytes[P_tmp[11]];
		

		for (int k = 0; k < 16; k++)
			C[k] = C[k] ^ ((W[(k/4)+56] >> (24-8*(k%4))) & 0xFF);
	

}


void AES256_dec(AES_STATE_t P, AES_STATE_t C, AES256_KEY_t K256)
{
	// Round Key(15)
	uint8_t SubBytes[256] = 
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};

	uint32_t W[60];
	for (int i = 0; i < 8; i++) {
		W[i] = (1<<24)*K256[0+4*i] + (1<<16)*K256[1+4*i] + (1<<8)*K256[2+4*i] + (1<<0)*K256[3+4*i];
	}

	for (int i = 0; i < 7; i++) {
		uint8_t k[4];
		k[0] = SubBytes[(W[8*i+7]/(256*256))%(256)];
		k[1] = SubBytes[(W[8*i+7]/256)%(256)];
		k[2] = SubBytes[W[8*i+7]%(256)];
		k[3] = SubBytes[(W[8*i+7]/(256*256*256))%(256)];

		W[8*i+8] = W[8*i] ^ ((1<<24)*(k[0] ^ Rcon(i+1)) + (1<<16)*k[1] + (1<<8)*k[2] + (1<<0)*k[3]);
		W[8*i+9] = W[8*i+1] ^ W[8*i+8];
		W[8*i+10] = W[8*i+2] ^ W[8*i+9];
		W[8*i+11] = W[8*i+3] ^ W[8*i+10];

		if (i < 6) {
			k[0] = SubBytes[W[8*i+11]%(256)];
			k[1] = SubBytes[(W[8*i+11]/256)%(256)];
			k[2] = SubBytes[(W[8*i+11]/(256*256))%(256)];
			k[3] = SubBytes[(W[8*i+11]/(256*256*256))%(256)];

			W[8*i+12] = W[8*i+4] ^ k[0] + (k[1]<<8) + (k[2]<<16) + (k[3]<<24);
			W[8*i+13] = W[8*i+5] ^ W[8*i+12];
			W[8*i+14] = W[8*i+6] ^ W[8*i+13];
			W[8*i+15] = W[8*i+7] ^ W[8*i+14];
		}
	}



	// T-Table
	typedef uint32_t T_Table_TMP;

	uint8_t Inv_SubBytes[256] = 
		{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};
	
	T_Table_TMP T0[256];
	T_Table_TMP T1[256];
	T_Table_TMP T2[256];
	T_Table_TMP T3[256];

	for (int i = 0; i < 256; i++)
	{
		uint8_t c = i;
		T0[i] = (1<<24)*GFMulti(c,0x0E) + (1<<16)*GFMulti(c,0x09) + (1<<8)*GFMulti(c,0x0D) + (1<<0)*GFMulti(c,0x0B);
		T1[i] = (1<<24)*GFMulti(c,0x0B) + (1<<16)*GFMulti(c,0x0E) + (1<<8)*GFMulti(c,0x09) + (1<<0)*GFMulti(c,0x0D);
		T2[i] = (1<<24)*GFMulti(c,0x0D) + (1<<16)*GFMulti(c,0x0B) + (1<<8)*GFMulti(c,0x0E) + (1<<0)*GFMulti(c,0x09);
		T3[i] = (1<<24)*GFMulti(c,0x09) + (1<<16)*GFMulti(c,0x0D) + (1<<8)*GFMulti(c,0x0B) + (1<<0)*GFMulti(c,0x0E);
	}

	// Round Iteration(14)
	AES_STATE_t P_tmp;
	memcpy(P_tmp, C, sizeof(AES_STATE_t));

	// Inv Final Round 
	for (int k = 0; k < 16; k++)
		P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+56] >> (24-8*(k%4))) & 0xFF);

	P[0] = Inv_SubBytes[P_tmp[0]];
	P[1] = Inv_SubBytes[P_tmp[13]];
	P[2] = Inv_SubBytes[P_tmp[10]];
	P[3] = Inv_SubBytes[P_tmp[7]];

	P[4] = Inv_SubBytes[P_tmp[4]];
	P[5] = Inv_SubBytes[P_tmp[1]];
	P[6] = Inv_SubBytes[P_tmp[14]];
	P[7] = Inv_SubBytes[P_tmp[11]];
	
	P[8] = Inv_SubBytes[P_tmp[8]];
	P[9] = Inv_SubBytes[P_tmp[5]];
	P[10] = Inv_SubBytes[P_tmp[2]];
	P[11] = Inv_SubBytes[P_tmp[15]];
	
	P[12] = Inv_SubBytes[P_tmp[12]];
	P[13] = Inv_SubBytes[P_tmp[9]];
	P[14] = Inv_SubBytes[P_tmp[6]];
	P[15] = Inv_SubBytes[P_tmp[3]];


	// Iteration
	for (int i = 0; i < 13; i++)
	{
		memcpy(P_tmp, P, sizeof(AES_STATE_t));
		
		for (int k = 0; k < 16; k++)
			P_tmp[k] = P_tmp[k] ^ ((W[(k/4)+4*(13-i)] >> (24-8*(k%4))) & 0xFF);
		
		P[0] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 24) & 0xFF];
		P[1] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 16) & 0xFF];
		P[2] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 8) & 0xFF];
		P[3] = Inv_SubBytes[(T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) & 0xFF];

		P[4] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 24) & 0xFF];
		P[5] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 16) & 0xFF];
		P[6] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 8) & 0xFF];
		P[7] = Inv_SubBytes[(T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) & 0xFF];

		P[8] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 24) & 0xFF];
		P[9] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 16) & 0xFF];
		P[10] = Inv_SubBytes[((T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) >> 8) & 0xFF];
		P[11] = Inv_SubBytes[(T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) & 0xFF];

		P[12] = Inv_SubBytes[((T0[P_tmp[12]]^T1[P_tmp[13]]^T2[P_tmp[14]]^T3[P_tmp[15]]) >> 24) & 0xFF];
		P[13] = Inv_SubBytes[((T0[P_tmp[8]]^T1[P_tmp[9]]^T2[P_tmp[10]]^T3[P_tmp[11]]) >> 16) & 0xFF];
		P[14] = Inv_SubBytes[((T0[P_tmp[4]]^T1[P_tmp[5]]^T2[P_tmp[6]]^T3[P_tmp[7]]) >> 8) & 0xFF];
		P[15] = Inv_SubBytes[(T0[P_tmp[0]]^T1[P_tmp[1]]^T2[P_tmp[2]]^T3[P_tmp[3]]) & 0xFF];
	}

	// Inv Round 0
	for (int k = 0; k < 16; k++)
		P[k] = P[k] ^ ((W[k/4] >> (24-8*(k%4))) & 0xFF);

}
